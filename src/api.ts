/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyDetectControlnetDetectPost
 */
export interface BodyDetectControlnetDetectPost {
    /**
     * 
     * @type {string}
     * @memberof BodyDetectControlnetDetectPost
     */
    'controlnet_module'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BodyDetectControlnetDetectPost
     */
    'controlnet_input_images'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    'controlnet_processor_res'?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    'controlnet_threshold_a'?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyDetectControlnetDetectPost
     */
    'controlnet_threshold_b'?: number;
}
/**
 * 
 * @export
 * @interface BodyRembgRemoveRembgPost
 */
export interface BodyRembgRemoveRembgPost {
    /**
     * 
     * @type {string}
     * @memberof BodyRembgRemoveRembgPost
     */
    'input_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyRembgRemoveRembgPost
     */
    'model'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BodyRembgRemoveRembgPost
     */
    'return_mask'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BodyRembgRemoveRembgPost
     */
    'alpha_matting'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BodyRembgRemoveRembgPost
     */
    'alpha_matting_foreground_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyRembgRemoveRembgPost
     */
    'alpha_matting_background_threshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof BodyRembgRemoveRembgPost
     */
    'alpha_matting_erode_size'?: number;
}
/**
 * 
 * @export
 * @interface CreateResponse
 */
export interface CreateResponse {
    /**
     * Response string from create embedding or hypernetwork task.
     * @type {string}
     * @memberof CreateResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface EmbeddingItem
 */
export interface EmbeddingItem {
    /**
     * The number of steps that were used to train this embedding, if available
     * @type {number}
     * @memberof EmbeddingItem
     */
    'step'?: number;
    /**
     * The hash of the checkpoint this embedding was trained on, if available
     * @type {string}
     * @memberof EmbeddingItem
     */
    'sd_checkpoint'?: string;
    /**
     * The name of the checkpoint this embedding was trained on, if available. Note that this is the name that was used by the trainer; for a stable identifier, use `sd_checkpoint` instead
     * @type {string}
     * @memberof EmbeddingItem
     */
    'sd_checkpoint_name'?: string;
    /**
     * The length of each individual vector in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    'shape': number;
    /**
     * The number of vectors in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    'vectors': number;
}
/**
 * 
 * @export
 * @interface EmbeddingsResponse
 */
export interface EmbeddingsResponse {
    /**
     * Embeddings loaded for the current model
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    'loaded': { [key: string]: EmbeddingItem; };
    /**
     * Embeddings skipped for the current model (likely due to architecture incompatibility)
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    'skipped': { [key: string]: EmbeddingItem; };
}
/**
 * 
 * @export
 * @interface Estimation
 */
export interface Estimation {
    /**
     * 
     * @type {string}
     * @memberof Estimation
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'queue_size': number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'avg_event_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'avg_event_concurrent_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'rank_eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'queue_eta': number;
}
/**
 * 
 * @export
 * @interface ExtrasBatchImagesRequest
 */
export interface ExtrasBatchImagesRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'resize_mode'?: ExtrasBatchImagesRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: 
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: 
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscale_first'?: boolean;
    /**
     * List of images to work on. Must be Base64 strings
     * @type {Array<FileData>}
     * @memberof ExtrasBatchImagesRequest
     */
    'imageList': Array<FileData>;
}

export const ExtrasBatchImagesRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasBatchImagesRequestResizeModeEnum = typeof ExtrasBatchImagesRequestResizeModeEnum[keyof typeof ExtrasBatchImagesRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasBatchImagesResponse
 */
export interface ExtrasBatchImagesResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasBatchImagesResponse
     */
    'html_info': string;
    /**
     * The generated images in base64 format.
     * @type {Array<string>}
     * @memberof ExtrasBatchImagesResponse
     */
    'images': Array<string>;
}
/**
 * 
 * @export
 * @interface ExtrasSingleImageRequest
 */
export interface ExtrasSingleImageRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'resize_mode'?: ExtrasSingleImageRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: 
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: 
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscale_first'?: boolean;
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'image'?: string;
}

export const ExtrasSingleImageRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasSingleImageRequestResizeModeEnum = typeof ExtrasSingleImageRequestResizeModeEnum[keyof typeof ExtrasSingleImageRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasSingleImageResponse
 */
export interface ExtrasSingleImageResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'html_info': string;
    /**
     * The generated image in base64 format.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface FaceRestorerItem
 */
export interface FaceRestorerItem {
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'cmd_dir'?: string;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * Base64 representation of the file
     * @type {string}
     * @memberof FileData
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Flags
 */
export interface Flags {
    /**
     * ==SUPPRESS==
     * @type {boolean}
     * @memberof Flags
     */
    'f'?: boolean;
    /**
     * launch.py argument: download updates for all extensions when starting the program
     * @type {boolean}
     * @memberof Flags
     */
    'update_all_extensions'?: boolean;
    /**
     * launch.py argument: do not check python version
     * @type {boolean}
     * @memberof Flags
     */
    'skip_python_version_check'?: boolean;
    /**
     * launch.py argument: do not check if CUDA is able to work properly
     * @type {boolean}
     * @memberof Flags
     */
    'skip_torch_cuda_test'?: boolean;
    /**
     * launch.py argument: install the appropriate version of xformers even if you have some version already installed
     * @type {boolean}
     * @memberof Flags
     */
    'reinstall_xformers'?: boolean;
    /**
     * launch.py argument: install the appropriate version of torch even if you have some version already installed
     * @type {boolean}
     * @memberof Flags
     */
    'reinstall_torch'?: boolean;
    /**
     * launch.py argument: chck for updates at startup
     * @type {boolean}
     * @memberof Flags
     */
    'update_check'?: boolean;
    /**
     * launch.py argument: configure server for testing
     * @type {boolean}
     * @memberof Flags
     */
    'test_server'?: boolean;
    /**
     * launch.py argument: skip all environment preparation
     * @type {boolean}
     * @memberof Flags
     */
    'skip_prepare_environment'?: boolean;
    /**
     * launch.py argument: skip installation of packages
     * @type {boolean}
     * @memberof Flags
     */
    'skip_install'?: boolean;
    /**
     * base path where all user data is stored
     * @type {string}
     * @memberof Flags
     */
    'data_dir'?: string;
    /**
     * path to config which constructs model
     * @type {string}
     * @memberof Flags
     */
    'config'?: string;
    /**
     * path to checkpoint of stable diffusion model; if specified, this checkpoint will be added to the list of checkpoints and loaded
     * @type {string}
     * @memberof Flags
     */
    'ckpt'?: string;
    /**
     * Path to directory with stable diffusion checkpoints
     * @type {string}
     * @memberof Flags
     */
    'ckpt_dir'?: string;
    /**
     * Path to directory with VAE files
     * @type {string}
     * @memberof Flags
     */
    'vae_dir'?: string;
    /**
     * GFPGAN directory
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_dir'?: string;
    /**
     * GFPGAN model file name
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_model'?: string;
    /**
     * do not switch the model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half'?: boolean;
    /**
     * do not switch the VAE model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half_vae'?: boolean;
    /**
     * do not hide progressbar in gradio UI (we hide it because it slows down ML if you have hardware acceleration in browser)
     * @type {boolean}
     * @memberof Flags
     */
    'no_progressbar_hiding'?: boolean;
    /**
     * maximum batch count value for the UI
     * @type {number}
     * @memberof Flags
     */
    'max_batch_count'?: number;
    /**
     * embeddings directory for textual inversion (default: embeddings)
     * @type {string}
     * @memberof Flags
     */
    'embeddings_dir'?: string;
    /**
     * directory with textual inversion templates
     * @type {string}
     * @memberof Flags
     */
    'textual_inversion_templates_dir'?: string;
    /**
     * hypernetwork directory
     * @type {string}
     * @memberof Flags
     */
    'hypernetwork_dir'?: string;
    /**
     * localizations directory
     * @type {string}
     * @memberof Flags
     */
    'localizations_dir'?: string;
    /**
     * allow custom script execution from webui
     * @type {boolean}
     * @memberof Flags
     */
    'allow_code'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a little speed for low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'medvram'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a lot of speed for very low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'lowvram'?: boolean;
    /**
     * load stable diffusion checkpoint weights to VRAM instead of RAM
     * @type {boolean}
     * @memberof Flags
     */
    'lowram'?: boolean;
    /**
     * disables cond/uncond batching that is enabled to save memory with --medvram or --lowvram
     * @type {boolean}
     * @memberof Flags
     */
    'always_batch_cond_uncond'?: boolean;
    /**
     * does not do anything.
     * @type {boolean}
     * @memberof Flags
     */
    'unload_gfpgan'?: boolean;
    /**
     * evaluate at this precision
     * @type {string}
     * @memberof Flags
     */
    'precision'?: string;
    /**
     * upcast sampling. No effect with --no-half. Usually produces similar results to --no-half with better performance while using less memory.
     * @type {boolean}
     * @memberof Flags
     */
    'upcast_sampling'?: boolean;
    /**
     * use share=True for gradio and make the UI accessible through their site
     * @type {boolean}
     * @memberof Flags
     */
    'share'?: boolean;
    /**
     * ngrok authtoken, alternative to gradio --share
     * @type {string}
     * @memberof Flags
     */
    'ngrok'?: string;
    /**
     * does not do anything.
     * @type {string}
     * @memberof Flags
     */
    'ngrok_region'?: string;
    /**
     * The options to pass to ngrok in JSON format, e.g.: \'{\"authtoken_from_env\":true, \"basic_auth\":\"user:password\", \"oauth_provider\":\"google\", \"oauth_allow_emails\":\"user@asdf.com\"}\'
     * @type {object}
     * @memberof Flags
     */
    'ngrok_options'?: object;
    /**
     * enable extensions tab regardless of other options
     * @type {boolean}
     * @memberof Flags
     */
    'enable_insecure_extension_access'?: boolean;
    /**
     * Path to directory with codeformer model file(s).
     * @type {string}
     * @memberof Flags
     */
    'codeformer_models_path'?: string;
    /**
     * Path to directory with GFPGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_models_path'?: string;
    /**
     * Path to directory with ESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'esrgan_models_path'?: string;
    /**
     * Path to directory with BSRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'bsrgan_models_path'?: string;
    /**
     * Path to directory with RealESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'realesrgan_models_path'?: string;
    /**
     * Path to directory with CLIP model file(s).
     * @type {string}
     * @memberof Flags
     */
    'clip_models_path'?: string;
    /**
     * enable xformers for cross attention layers
     * @type {boolean}
     * @memberof Flags
     */
    'xformers'?: boolean;
    /**
     * enable xformers for cross attention layers regardless of whether the checking code thinks you can run it; do not make bug reports if this fails to work
     * @type {boolean}
     * @memberof Flags
     */
    'force_enable_xformers'?: boolean;
    /**
     * enable xformers with Flash Attention to improve reproducibility (supported for SD2.x or variant only)
     * @type {boolean}
     * @memberof Flags
     */
    'xformers_flash_attention'?: boolean;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'deepdanbooru'?: boolean;
    /**
     * prefer Doggettx\'s cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention'?: boolean;
    /**
     * prefer memory efficient sub-quadratic cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sub_quad_attention'?: boolean;
    /**
     * query chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {number}
     * @memberof Flags
     */
    'sub_quad_q_chunk_size'?: number;
    /**
     * kv chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {string}
     * @memberof Flags
     */
    'sub_quad_kv_chunk_size'?: string;
    /**
     * the percentage of VRAM threshold for the sub-quadratic cross-attention layer optimization to use chunking
     * @type {string}
     * @memberof Flags
     */
    'sub_quad_chunk_threshold'?: string;
    /**
     * prefer InvokeAI\'s cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_invokeai'?: boolean;
    /**
     * prefer older version of split attention optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_v1'?: boolean;
    /**
     * prefer scaled dot product cross-attention layer optimization for automatic choice of optimization; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sdp_attention'?: boolean;
    /**
     * prefer scaled dot product cross-attention layer optimization without memory efficient attention for automatic choice of optimization, makes image generation deterministic; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sdp_no_mem_attention'?: boolean;
    /**
     * prefer no cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'disable_opt_split_attention'?: boolean;
    /**
     * do not check if produced images/latent spaces have nans; useful for running without a checkpoint in CI
     * @type {boolean}
     * @memberof Flags
     */
    'disable_nan_check'?: boolean;
    /**
     * use CPU as torch device for specified modules
     * @type {Array<any>}
     * @memberof Flags
     */
    'use_cpu'?: Array<any>;
    /**
     * launch gradio with 0.0.0.0 as server name, allowing to respond to network requests
     * @type {boolean}
     * @memberof Flags
     */
    'listen'?: boolean;
    /**
     * launch gradio with given server port, you need root/admin rights for ports < 1024, defaults to 7860 if available
     * @type {string}
     * @memberof Flags
     */
    'port'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'show_negative_prompt'?: boolean;
    /**
     * filename to use for ui configuration
     * @type {string}
     * @memberof Flags
     */
    'ui_config_file'?: string;
    /**
     * hide directory configuration from webui
     * @type {boolean}
     * @memberof Flags
     */
    'hide_ui_dir_config'?: boolean;
    /**
     * disable editing settings
     * @type {boolean}
     * @memberof Flags
     */
    'freeze_settings'?: boolean;
    /**
     * filename to use for ui settings
     * @type {string}
     * @memberof Flags
     */
    'ui_settings_file'?: string;
    /**
     * launch gradio with --debug option
     * @type {boolean}
     * @memberof Flags
     */
    'gradio_debug'?: boolean;
    /**
     * set gradio authentication like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    'gradio_auth'?: string;
    /**
     * set gradio authentication file path ex. \"/path/to/auth/file\" same auth format as --gradio-auth
     * @type {string}
     * @memberof Flags
     */
    'gradio_auth_path'?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    'gradio_img2img_tool'?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    'gradio_inpaint_tool'?: string;
    /**
     * add path to gradio\'s allowed_paths, make it possible to serve files from it
     * @type {string}
     * @memberof Flags
     */
    'gradio_allowed_path'?: string;
    /**
     * change memory type for stable diffusion to channels last
     * @type {boolean}
     * @memberof Flags
     */
    'opt_channelslast'?: boolean;
    /**
     * filename to use for styles
     * @type {string}
     * @memberof Flags
     */
    'styles_file'?: string;
    /**
     * open the webui URL in the system\'s default browser upon launch
     * @type {boolean}
     * @memberof Flags
     */
    'autolaunch'?: boolean;
    /**
     * launches the UI with light or dark theme
     * @type {string}
     * @memberof Flags
     */
    'theme'?: string;
    /**
     * use textbox for seeds in UI (no up/down, but possible to input long seeds)
     * @type {boolean}
     * @memberof Flags
     */
    'use_textbox_seed'?: boolean;
    /**
     * do not output progressbars to console
     * @type {boolean}
     * @memberof Flags
     */
    'disable_console_progressbars'?: boolean;
    /**
     * print prompts to console when generating with txt2img and img2img
     * @type {boolean}
     * @memberof Flags
     */
    'enable_console_prompts'?: boolean;
    /**
     * Checkpoint to use as VAE; setting this argument disables all settings related to VAE
     * @type {string}
     * @memberof Flags
     */
    'vae_path'?: string;
    /**
     * disable checking pytorch models for malicious code
     * @type {boolean}
     * @memberof Flags
     */
    'disable_safe_unpickle'?: boolean;
    /**
     * use api=True to launch the API together with the webui (use --nowebui instead for only the API)
     * @type {boolean}
     * @memberof Flags
     */
    'api'?: boolean;
    /**
     * Set authentication for API like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    'api_auth'?: string;
    /**
     * use api-log=True to enable logging of all API requests
     * @type {boolean}
     * @memberof Flags
     */
    'api_log'?: boolean;
    /**
     * use api=True to launch the API instead of the webui
     * @type {boolean}
     * @memberof Flags
     */
    'nowebui'?: boolean;
    /**
     * Don\'t load model to quickly launch UI
     * @type {boolean}
     * @memberof Flags
     */
    'ui_debug_mode'?: boolean;
    /**
     * Select the default CUDA device to use (export CUDA_VISIBLE_DEVICES=0,1,etc might be needed before)
     * @type {string}
     * @memberof Flags
     */
    'device_id'?: string;
    /**
     * Administrator rights
     * @type {boolean}
     * @memberof Flags
     */
    'administrator'?: boolean;
    /**
     * Allowed CORS origin(s) in the form of a comma-separated list (no spaces)
     * @type {string}
     * @memberof Flags
     */
    'cors_allow_origins'?: string;
    /**
     * Allowed CORS origin(s) in the form of a single regular expression
     * @type {string}
     * @memberof Flags
     */
    'cors_allow_origins_regex'?: string;
    /**
     * Partially enables TLS, requires --tls-certfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_keyfile'?: string;
    /**
     * Partially enables TLS, requires --tls-keyfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_certfile'?: string;
    /**
     * When passed, enables the use of self-signed certificates.
     * @type {string}
     * @memberof Flags
     */
    'disable_tls_verify'?: string;
    /**
     * Sets hostname of server
     * @type {string}
     * @memberof Flags
     */
    'server_name'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'gradio_queue'?: boolean;
    /**
     * Disables gradio queue; causes the webpage to use http requests instead of websockets; was the defaul in earlier versions
     * @type {boolean}
     * @memberof Flags
     */
    'no_gradio_queue'?: boolean;
    /**
     * Do not check versions of torch and xformers
     * @type {boolean}
     * @memberof Flags
     */
    'skip_version_check'?: boolean;
    /**
     * disable sha256 hashing of checkpoints to help loading performance
     * @type {boolean}
     * @memberof Flags
     */
    'no_hashing'?: boolean;
    /**
     * don\'t download SD1.5 model even if no model is found in --ckpt-dir
     * @type {boolean}
     * @memberof Flags
     */
    'no_download_sd_model'?: boolean;
    /**
     * customize the subpath for gradio, use with reverse proxy
     * @type {string}
     * @memberof Flags
     */
    'subpath'?: string;
    /**
     * add /_stop route to stop server
     * @type {boolean}
     * @memberof Flags
     */
    'add_stop_route'?: boolean;
    /**
     * Path to directory with LyCORIS networks.
     * @type {string}
     * @memberof Flags
     */
    'lyco_dir'?: string;
    /**
     * Patch the built-in lora. Will use the lora_dir and <lora> format, but disable the <lyco> format.
     * @type {boolean}
     * @memberof Flags
     */
    'lyco_patch_lora'?: boolean;
    /**
     * Print extra info when using lycoris model
     * @type {boolean}
     * @memberof Flags
     */
    'lyco_debug'?: boolean;
    /**
     * Path to directory with ControlNet models
     * @type {string}
     * @memberof Flags
     */
    'controlnet_dir'?: string;
    /**
     * Path to directory with annotator model directories
     * @type {string}
     * @memberof Flags
     */
    'controlnet_annotator_models_path'?: string;
    /**
     * do not switch the ControlNet models to 16-bit floats (only needed without --no-half)
     * @type {string}
     * @memberof Flags
     */
    'no_half_controlnet'?: string;
    /**
     * Cache size for controlnet preprocessor results
     * @type {number}
     * @memberof Flags
     */
    'controlnet_preprocessor_cache_size'?: number;
    /**
     * Set the log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
     * @type {string}
     * @memberof Flags
     */
    'controlnet_loglevel'?: string;
    /**
     * Path to directory with DeepDanbooru project(s).
     * @type {string}
     * @memberof Flags
     */
    'deepdanbooru_projects_path'?: string;
    /**
     * Path to directory with LDSR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'ldsr_models_path'?: string;
    /**
     * Path to directory with Lora networks.
     * @type {string}
     * @memberof Flags
     */
    'lora_dir'?: string;
    /**
     * Path to directory with ScuNET model file(s).
     * @type {string}
     * @memberof Flags
     */
    'scunet_models_path'?: string;
    /**
     * Path to directory with SwinIR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'swinir_models_path'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HypernetworkItem
 */
export interface HypernetworkItem {
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface ImageToImageResponse
 */
export interface ImageToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof ImageToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ImageToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof ImageToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface InterrogateRequest
 */
export interface InterrogateRequest {
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'image'?: string;
    /**
     * The interrogate model used.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'model'?: string;
}
/**
 * 
 * @export
 * @interface InterrogatorsResponse
 */
export interface InterrogatorsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof InterrogatorsResponse
     */
    'models': Array<string>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface MemoryResponse
 */
export interface MemoryResponse {
    /**
     * System memory stats
     * @type {object}
     * @memberof MemoryResponse
     */
    'ram': object;
    /**
     * nVidia CUDA memory stats
     * @type {object}
     * @memberof MemoryResponse
     */
    'cuda': object;
}
/**
 * 
 * @export
 * @interface ModulesApiModelsProgressResponse
 */
export interface ModulesApiModelsProgressResponse {
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    'eta_relative': number;
    /**
     * The current state snapshot
     * @type {object}
     * @memberof ModulesApiModelsProgressResponse
     */
    'state': object;
    /**
     * The current image in base64 format. opts.show_progress_every_n_steps is required for this to work.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    'current_image'?: string;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    'textinfo'?: string;
}
/**
 * 
 * @export
 * @interface ModulesProgressProgressResponse
 */
export interface ModulesProgressProgressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'queued': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'completed': boolean;
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'progress'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'eta'?: number;
    /**
     * Current live preview; a data: uri
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    'live_preview'?: string;
    /**
     * Send this together with next request to prevent receiving same image
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'id_live_preview'?: number;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    'textinfo'?: string;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * Always save all generated images
     * @type {boolean}
     * @memberof Options
     */
    'samples_save'?: boolean;
    /**
     * File format for images
     * @type {string}
     * @memberof Options
     */
    'samples_format'?: string;
    /**
     * Images filename pattern
     * @type {string}
     * @memberof Options
     */
    'samples_filename_pattern'?: string;
    /**
     * Add number to filename when saving
     * @type {boolean}
     * @memberof Options
     */
    'save_images_add_number'?: boolean;
    /**
     * Always save all generated image grids
     * @type {boolean}
     * @memberof Options
     */
    'grid_save'?: boolean;
    /**
     * File format for grids
     * @type {string}
     * @memberof Options
     */
    'grid_format'?: string;
    /**
     * Add extended info (seed, prompt) to filename when saving grid
     * @type {boolean}
     * @memberof Options
     */
    'grid_extended_filename'?: boolean;
    /**
     * Do not save grids consisting of one picture
     * @type {boolean}
     * @memberof Options
     */
    'grid_only_if_multiple'?: boolean;
    /**
     * Prevent empty spots in grid (when set to autodetect)
     * @type {boolean}
     * @memberof Options
     */
    'grid_prevent_empty_spots'?: boolean;
    /**
     * Grid row count; use -1 for autodetect and 0 for it to be same as batch size
     * @type {number}
     * @memberof Options
     */
    'n_rows'?: number;
    /**
     * Save text information about generation parameters as chunks to png files
     * @type {boolean}
     * @memberof Options
     */
    'enable_pnginfo'?: boolean;
    /**
     * Create a text file next to every image with generation parameters.
     * @type {boolean}
     * @memberof Options
     */
    'save_txt'?: boolean;
    /**
     * Save a copy of image before doing face restoration.
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_face_restoration'?: boolean;
    /**
     * Save a copy of image before applying highres fix.
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_highres_fix'?: boolean;
    /**
     * Save a copy of image before applying color correction to img2img results
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_color_correction'?: boolean;
    /**
     * For inpainting, save a copy of the greyscale mask
     * @type {boolean}
     * @memberof Options
     */
    'save_mask'?: boolean;
    /**
     * For inpainting, save a masked composite
     * @type {boolean}
     * @memberof Options
     */
    'save_mask_composite'?: boolean;
    /**
     * Quality for saved jpeg images
     * @type {number}
     * @memberof Options
     */
    'jpeg_quality'?: number;
    /**
     * Use lossless compression for webp images
     * @type {boolean}
     * @memberof Options
     */
    'webp_lossless'?: boolean;
    /**
     * Save copy of large images as JPG
     * @type {boolean}
     * @memberof Options
     */
    'export_for_4chan'?: boolean;
    /**
     * File size limit for the above option, MB
     * @type {number}
     * @memberof Options
     */
    'img_downscale_threshold'?: number;
    /**
     * Width/height limit for the above option, in pixels
     * @type {number}
     * @memberof Options
     */
    'target_side_length'?: number;
    /**
     * Maximum image size
     * @type {number}
     * @memberof Options
     */
    'img_max_size_mp'?: number;
    /**
     * Use original name for output filename during batch process in extras tab
     * @type {boolean}
     * @memberof Options
     */
    'use_original_name_batch'?: boolean;
    /**
     * Use upscaler name as filename suffix in the extras tab
     * @type {boolean}
     * @memberof Options
     */
    'use_upscaler_name_as_suffix'?: boolean;
    /**
     * When using \'Save\' button, only save a single selected image
     * @type {boolean}
     * @memberof Options
     */
    'save_selected_only'?: boolean;
    /**
     * Save init images when using img2img
     * @type {boolean}
     * @memberof Options
     */
    'save_init_img'?: boolean;
    /**
     * Directory for temporary images; leave empty for default
     * @type {string}
     * @memberof Options
     */
    'temp_dir'?: string;
    /**
     * Cleanup non-default temporary directory when starting webui
     * @type {boolean}
     * @memberof Options
     */
    'clean_temp_dir_at_start'?: boolean;
    /**
     * Output directory for images; if empty, defaults to three directories below
     * @type {string}
     * @memberof Options
     */
    'outdir_samples'?: string;
    /**
     * Output directory for txt2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_samples'?: string;
    /**
     * Output directory for img2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_samples'?: string;
    /**
     * Output directory for images from extras tab
     * @type {string}
     * @memberof Options
     */
    'outdir_extras_samples'?: string;
    /**
     * Output directory for grids; if empty, defaults to two directories below
     * @type {string}
     * @memberof Options
     */
    'outdir_grids'?: string;
    /**
     * Output directory for txt2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_grids'?: string;
    /**
     * Output directory for img2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_grids'?: string;
    /**
     * Directory for saving images using the Save button
     * @type {string}
     * @memberof Options
     */
    'outdir_save'?: string;
    /**
     * Directory for saving init images when using img2img
     * @type {string}
     * @memberof Options
     */
    'outdir_init_images'?: string;
    /**
     * Save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'save_to_dirs'?: boolean;
    /**
     * Save grids to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'grid_save_to_dirs'?: boolean;
    /**
     * When using \"Save\" button, save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'use_save_to_dirs_for_ui'?: boolean;
    /**
     * Directory name pattern
     * @type {string}
     * @memberof Options
     */
    'directories_filename_pattern'?: string;
    /**
     * Max prompt words for [prompt_words] pattern
     * @type {number}
     * @memberof Options
     */
    'directories_max_prompt_words'?: number;
    /**
     * Tile size for ESRGAN upscalers.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile'?: number;
    /**
     * Tile overlap for ESRGAN upscalers.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile_overlap'?: number;
    /**
     * Select which Real-ESRGAN models to show in the web UI.
     * @type {Array<any>}
     * @memberof Options
     */
    'realesrgan_enabled_models'?: Array<any>;
    /**
     * Upscaler for img2img
     * @type {string}
     * @memberof Options
     */
    'upscaler_for_img2img'?: string;
    /**
     * Face restoration model
     * @type {string}
     * @memberof Options
     */
    'face_restoration_model'?: string;
    /**
     * CodeFormer weight
     * @type {number}
     * @memberof Options
     */
    'code_former_weight'?: number;
    /**
     * Move face restoration model from VRAM into RAM after processing
     * @type {boolean}
     * @memberof Options
     */
    'face_restoration_unload'?: boolean;
    /**
     * Show warnings in console.
     * @type {boolean}
     * @memberof Options
     */
    'show_warnings'?: boolean;
    /**
     * VRAM usage polls per second during generation.
     * @type {number}
     * @memberof Options
     */
    'memmon_poll_rate'?: number;
    /**
     * Always print all generation info to standard output
     * @type {boolean}
     * @memberof Options
     */
    'samples_log_stdout'?: boolean;
    /**
     * Add a second progress bar to the console that shows progress for an entire job.
     * @type {boolean}
     * @memberof Options
     */
    'multiple_tqdm'?: boolean;
    /**
     * Print extra hypernetwork information to console.
     * @type {boolean}
     * @memberof Options
     */
    'print_hypernet_extra'?: boolean;
    /**
     * Load models/files in hidden directories
     * @type {boolean}
     * @memberof Options
     */
    'list_hidden_files'?: boolean;
    /**
     * Move VAE and CLIP to RAM when training if possible. Saves VRAM.
     * @type {boolean}
     * @memberof Options
     */
    'unload_models_when_training'?: boolean;
    /**
     * Turn on pin_memory for DataLoader. Makes training slightly faster but can increase memory usage.
     * @type {boolean}
     * @memberof Options
     */
    'pin_memory'?: boolean;
    /**
     * Saves Optimizer state as separate *.optim file. Training of embedding or HN can be resumed with the matching optim file.
     * @type {boolean}
     * @memberof Options
     */
    'save_optimizer_state'?: boolean;
    /**
     * Save textual inversion and hypernet settings to a text file whenever training starts.
     * @type {boolean}
     * @memberof Options
     */
    'save_training_settings_to_txt'?: boolean;
    /**
     * Filename word regex
     * @type {string}
     * @memberof Options
     */
    'dataset_filename_word_regex'?: string;
    /**
     * Filename join string
     * @type {string}
     * @memberof Options
     */
    'dataset_filename_join_string'?: string;
    /**
     * Number of repeats for a single input image per epoch; used only for displaying epoch number
     * @type {number}
     * @memberof Options
     */
    'training_image_repeats_per_epoch'?: number;
    /**
     * Save an csv containing the loss to log directory every N steps, 0 to disable
     * @type {number}
     * @memberof Options
     */
    'training_write_csv_every'?: number;
    /**
     * Use cross attention optimizations while training
     * @type {boolean}
     * @memberof Options
     */
    'training_xattention_optimizations'?: boolean;
    /**
     * Enable tensorboard logging.
     * @type {boolean}
     * @memberof Options
     */
    'training_enable_tensorboard'?: boolean;
    /**
     * Save generated images within tensorboard.
     * @type {boolean}
     * @memberof Options
     */
    'training_tensorboard_save_images'?: boolean;
    /**
     * How often, in seconds, to flush the pending tensorboard events and summaries to disk.
     * @type {number}
     * @memberof Options
     */
    'training_tensorboard_flush_every'?: number;
    /**
     * Stable Diffusion checkpoint
     * @type {string}
     * @memberof Options
     */
    'sd_model_checkpoint'?: string;
    /**
     * Checkpoints to cache in RAM
     * @type {number}
     * @memberof Options
     */
    'sd_checkpoint_cache'?: number;
    /**
     * VAE Checkpoints to cache in RAM
     * @type {number}
     * @memberof Options
     */
    'sd_vae_checkpoint_cache'?: number;
    /**
     * SD VAE
     * @type {string}
     * @memberof Options
     */
    'sd_vae'?: string;
    /**
     * Ignore selected VAE for stable diffusion checkpoints that have their own .vae.pt next to them
     * @type {boolean}
     * @memberof Options
     */
    'sd_vae_as_default'?: boolean;
    /**
     * Inpainting conditioning mask strength
     * @type {number}
     * @memberof Options
     */
    'inpainting_mask_weight'?: number;
    /**
     * Noise multiplier for img2img
     * @type {number}
     * @memberof Options
     */
    'initial_noise_multiplier'?: number;
    /**
     * Apply color correction to img2img results to match original colors.
     * @type {boolean}
     * @memberof Options
     */
    'img2img_color_correction'?: boolean;
    /**
     * With img2img, do exactly the amount of steps the slider specifies.
     * @type {boolean}
     * @memberof Options
     */
    'img2img_fix_steps'?: boolean;
    /**
     * With img2img, fill image\'s transparent parts with this color.
     * @type {string}
     * @memberof Options
     */
    'img2img_background_color'?: string;
    /**
     * Enable quantization in K samplers for sharper and cleaner results. This may change existing seeds. Requires restart to apply.
     * @type {boolean}
     * @memberof Options
     */
    'enable_quantization'?: boolean;
    /**
     * Enable emphasis
     * @type {boolean}
     * @memberof Options
     */
    'enable_emphasis'?: boolean;
    /**
     * Make K-diffusion samplers produce same images in a batch as when making a single image
     * @type {boolean}
     * @memberof Options
     */
    'enable_batch_seeds'?: boolean;
    /**
     * Prompt word wrap length limit
     * @type {number}
     * @memberof Options
     */
    'comma_padding_backtrack'?: number;
    /**
     * Clip skip
     * @type {number}
     * @memberof Options
     */
    'CLIP_stop_at_last_layers'?: number;
    /**
     * Upcast cross attention layer to float32
     * @type {boolean}
     * @memberof Options
     */
    'upcast_attn'?: boolean;
    /**
     * Random number generator source.
     * @type {string}
     * @memberof Options
     */
    'randn_source'?: string;
    /**
     * Cross attention optimization
     * @type {string}
     * @memberof Options
     */
    'cross_attention_optimization'?: string;
    /**
     * Negative Guidance minimum sigma
     * @type {number}
     * @memberof Options
     */
    's_min_uncond'?: number;
    /**
     * Token merging ratio
     * @type {number}
     * @memberof Options
     */
    'token_merging_ratio'?: number;
    /**
     * Token merging ratio for img2img
     * @type {number}
     * @memberof Options
     */
    'token_merging_ratio_img2img'?: number;
    /**
     * Token merging ratio for high-res pass
     * @type {number}
     * @memberof Options
     */
    'token_merging_ratio_hr'?: number;
    /**
     * Use old emphasis implementation. Can be useful to reproduce old seeds.
     * @type {boolean}
     * @memberof Options
     */
    'use_old_emphasis_implementation'?: boolean;
    /**
     * Use old karras scheduler sigmas (0.1 to 10).
     * @type {boolean}
     * @memberof Options
     */
    'use_old_karras_scheduler_sigmas'?: boolean;
    /**
     * Do not make DPM++ SDE deterministic across different batch sizes.
     * @type {boolean}
     * @memberof Options
     */
    'no_dpmpp_sde_batch_determinism'?: boolean;
    /**
     * For hires fix, use width/height sliders to set final resolution rather than first pass (disables Upscale by, Resize width/height to).
     * @type {boolean}
     * @memberof Options
     */
    'use_old_hires_fix_width_height'?: boolean;
    /**
     * Do not fix prompt schedule for second order samplers.
     * @type {boolean}
     * @memberof Options
     */
    'dont_fix_second_order_samplers_schedule'?: boolean;
    /**
     * Keep models in VRAM
     * @type {boolean}
     * @memberof Options
     */
    'interrogate_keep_models_in_memory'?: boolean;
    /**
     * Include ranks of model tags matches in results.
     * @type {boolean}
     * @memberof Options
     */
    'interrogate_return_ranks'?: boolean;
    /**
     * BLIP: num_beams
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_num_beams'?: number;
    /**
     * BLIP: minimum description length
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_min_length'?: number;
    /**
     * BLIP: maximum description length
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_max_length'?: number;
    /**
     * CLIP: maximum number of lines in text file
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_dict_limit'?: number;
    /**
     * CLIP: skip inquire categories
     * @type {Array<any>}
     * @memberof Options
     */
    'interrogate_clip_skip_categories'?: Array<any>;
    /**
     * deepbooru: score threshold
     * @type {number}
     * @memberof Options
     */
    'interrogate_deepbooru_score_threshold'?: number;
    /**
     * deepbooru: sort tags alphabetically
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_sort_alpha'?: boolean;
    /**
     * deepbooru: use spaces in tags
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_use_spaces'?: boolean;
    /**
     * deepbooru: escape (\\) brackets
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_escape'?: boolean;
    /**
     * deepbooru: filter out those tags
     * @type {string}
     * @memberof Options
     */
    'deepbooru_filter_tags'?: string;
    /**
     * Show hidden directories
     * @type {boolean}
     * @memberof Options
     */
    'extra_networks_show_hidden_directories'?: boolean;
    /**
     * Show cards for models in hidden directories
     * @type {string}
     * @memberof Options
     */
    'extra_networks_hidden_models'?: string;
    /**
     * Default view for Extra Networks
     * @type {string}
     * @memberof Options
     */
    'extra_networks_default_view'?: string;
    /**
     * Multiplier for extra networks
     * @type {number}
     * @memberof Options
     */
    'extra_networks_default_multiplier'?: number;
    /**
     * Card width for Extra Networks
     * @type {number}
     * @memberof Options
     */
    'extra_networks_card_width'?: number;
    /**
     * Card height for Extra Networks
     * @type {number}
     * @memberof Options
     */
    'extra_networks_card_height'?: number;
    /**
     * Extra networks separator
     * @type {string}
     * @memberof Options
     */
    'extra_networks_add_text_separator'?: string;
    /**
     * Extra networks tab order
     * @type {string}
     * @memberof Options
     */
    'ui_extra_networks_tab_reorder'?: string;
    /**
     * Add hypernetwork to prompt
     * @type {string}
     * @memberof Options
     */
    'sd_hypernetwork'?: string;
    /**
     * Localization
     * @type {string}
     * @memberof Options
     */
    'localization'?: string;
    /**
     * Gradio theme
     * @type {string}
     * @memberof Options
     */
    'gradio_theme'?: string;
    /**
     * img2img: height of image editor
     * @type {number}
     * @memberof Options
     */
    'img2img_editor_height'?: number;
    /**
     * Show grid in results for web
     * @type {boolean}
     * @memberof Options
     */
    'return_grid'?: boolean;
    /**
     * For inpainting, include the greyscale mask in results for web
     * @type {boolean}
     * @memberof Options
     */
    'return_mask'?: boolean;
    /**
     * For inpainting, include masked composite in results for web
     * @type {boolean}
     * @memberof Options
     */
    'return_mask_composite'?: boolean;
    /**
     * Do not show any images in results for web
     * @type {boolean}
     * @memberof Options
     */
    'do_not_show_images'?: boolean;
    /**
     * Send seed when sending prompt or image to other interface
     * @type {boolean}
     * @memberof Options
     */
    'send_seed'?: boolean;
    /**
     * Send size when sending prompt or image to another interface
     * @type {boolean}
     * @memberof Options
     */
    'send_size'?: boolean;
    /**
     * Font for image grids that have text
     * @type {string}
     * @memberof Options
     */
    'font'?: string;
    /**
     * Enable full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox'?: boolean;
    /**
     * Show images zoomed in by default in full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox_initially_zoomed'?: boolean;
    /**
     * Navigate image viewer with gamepad
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox_gamepad'?: boolean;
    /**
     * Gamepad repeat period, in milliseconds
     * @type {number}
     * @memberof Options
     */
    'js_modal_lightbox_gamepad_repeat'?: number;
    /**
     * Show generation progress in window title.
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_in_title'?: boolean;
    /**
     * Use dropdown for sampler selection instead of radio group
     * @type {boolean}
     * @memberof Options
     */
    'samplers_in_dropdown'?: boolean;
    /**
     * Show Width/Height and Batch sliders in same row
     * @type {boolean}
     * @memberof Options
     */
    'dimensions_and_batch_together'?: boolean;
    /**
     * Ctrl+up/down precision when editing (attention:1.1)
     * @type {number}
     * @memberof Options
     */
    'keyedit_precision_attention'?: number;
    /**
     * Ctrl+up/down precision when editing <extra networks:0.9>
     * @type {number}
     * @memberof Options
     */
    'keyedit_precision_extra'?: number;
    /**
     * Ctrl+up/down word delimiters
     * @type {string}
     * @memberof Options
     */
    'keyedit_delimiters'?: string;
    /**
     * Quicksettings list
     * @type {Array<any>}
     * @memberof Options
     */
    'quicksettings_list'?: Array<any>;
    /**
     * UI tab order
     * @type {Array<any>}
     * @memberof Options
     */
    'ui_tab_order'?: Array<any>;
    /**
     * Hidden UI tabs
     * @type {Array<any>}
     * @memberof Options
     */
    'hidden_tabs'?: Array<any>;
    /**
     * txt2img/img2img UI item order
     * @type {string}
     * @memberof Options
     */
    'ui_reorder'?: string;
    /**
     * Hires fix: show hires sampler selection
     * @type {boolean}
     * @memberof Options
     */
    'hires_fix_show_sampler'?: boolean;
    /**
     * Hires fix: show hires prompt and negative prompt
     * @type {boolean}
     * @memberof Options
     */
    'hires_fix_show_prompts'?: boolean;
    /**
     * Add model hash to generation information
     * @type {boolean}
     * @memberof Options
     */
    'add_model_hash_to_info'?: boolean;
    /**
     * Add model name to generation information
     * @type {boolean}
     * @memberof Options
     */
    'add_model_name_to_info'?: boolean;
    /**
     * Add program version to generation information
     * @type {boolean}
     * @memberof Options
     */
    'add_version_to_infotext'?: boolean;
    /**
     * When reading generation parameters from text into UI (from PNG info or pasted text), do not change the selected model/checkpoint.
     * @type {boolean}
     * @memberof Options
     */
    'disable_weights_auto_swap'?: boolean;
    /**
     * Show progressbar
     * @type {boolean}
     * @memberof Options
     */
    'show_progressbar'?: boolean;
    /**
     * Show live previews of the created image
     * @type {boolean}
     * @memberof Options
     */
    'live_previews_enable'?: boolean;
    /**
     * Live preview file format
     * @type {string}
     * @memberof Options
     */
    'live_previews_image_format'?: string;
    /**
     * Show previews of all images generated in a batch as a grid
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_grid'?: boolean;
    /**
     * Live preview display period
     * @type {number}
     * @memberof Options
     */
    'show_progress_every_n_steps'?: number;
    /**
     * Live preview method
     * @type {string}
     * @memberof Options
     */
    'show_progress_type'?: string;
    /**
     * Live preview subject
     * @type {string}
     * @memberof Options
     */
    'live_preview_content'?: string;
    /**
     * Progressbar and preview update period
     * @type {number}
     * @memberof Options
     */
    'live_preview_refresh_period'?: number;
    /**
     * Hide samplers in user interface
     * @type {Array<any>}
     * @memberof Options
     */
    'hide_samplers'?: Array<any>;
    /**
     * Eta for DDIM
     * @type {number}
     * @memberof Options
     */
    'eta_ddim'?: number;
    /**
     * Eta for ancestral samplers
     * @type {number}
     * @memberof Options
     */
    'eta_ancestral'?: number;
    /**
     * img2img DDIM discretize
     * @type {string}
     * @memberof Options
     */
    'ddim_discretize'?: string;
    /**
     * sigma churn
     * @type {number}
     * @memberof Options
     */
    's_churn'?: number;
    /**
     * sigma tmin
     * @type {number}
     * @memberof Options
     */
    's_tmin'?: number;
    /**
     * sigma noise
     * @type {number}
     * @memberof Options
     */
    's_noise'?: number;
    /**
     * Eta noise seed delta
     * @type {number}
     * @memberof Options
     */
    'eta_noise_seed_delta'?: number;
    /**
     * Always discard next-to-last sigma
     * @type {boolean}
     * @memberof Options
     */
    'always_discard_next_to_last_sigma'?: boolean;
    /**
     * UniPC variant
     * @type {string}
     * @memberof Options
     */
    'uni_pc_variant'?: string;
    /**
     * UniPC skip type
     * @type {string}
     * @memberof Options
     */
    'uni_pc_skip_type'?: string;
    /**
     * UniPC order
     * @type {number}
     * @memberof Options
     */
    'uni_pc_order'?: number;
    /**
     * UniPC lower order final
     * @type {boolean}
     * @memberof Options
     */
    'uni_pc_lower_order_final'?: boolean;
    /**
     * Enable postprocessing operations in txt2img and img2img tabs
     * @type {Array<any>}
     * @memberof Options
     */
    'postprocessing_enable_in_main_ui'?: Array<any>;
    /**
     * Postprocessing operation order
     * @type {Array<any>}
     * @memberof Options
     */
    'postprocessing_operation_order'?: Array<any>;
    /**
     * Maximum number of images in upscaling cache
     * @type {number}
     * @memberof Options
     */
    'upscaling_max_images_in_cache'?: number;
    /**
     * Disable these extensions
     * @type {Array<any>}
     * @memberof Options
     */
    'disabled_extensions'?: Array<any>;
    /**
     * Disable all extensions (preserves the list of disabled extensions)
     * @type {string}
     * @memberof Options
     */
    'disable_all_extensions'?: string;
    /**
     * Config state file to restore from, under \'config-states/\' folder
     * @type {string}
     * @memberof Options
     */
    'restore_config_state_file'?: string;
    /**
     * SHA256 hash of the current checkpoint
     * @type {string}
     * @memberof Options
     */
    'sd_checkpoint_hash'?: string;
    /**
     * Add LyCORIS to prompt
     * @type {string}
     * @memberof Options
     */
    'sd_lyco'?: string;
}
/**
 * 
 * @export
 * @interface PNGInfoRequest
 */
export interface PNGInfoRequest {
    /**
     * The base64 encoded PNG image
     * @type {string}
     * @memberof PNGInfoRequest
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PNGInfoResponse
 */
export interface PNGInfoResponse {
    /**
     * A string with the parameters used to generate the image
     * @type {string}
     * @memberof PNGInfoResponse
     */
    'info': string;
    /**
     * An object containing all the info the image had
     * @type {object}
     * @memberof PNGInfoResponse
     */
    'items': object;
}
/**
 * 
 * @export
 * @interface PredictBody
 */
export interface PredictBody {
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    'session_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    'event_id'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof PredictBody
     */
    'data': Array<any>;
    /**
     * 
     * @type {any}
     * @memberof PredictBody
     */
    'event_data'?: any;
    /**
     * 
     * @type {number}
     * @memberof PredictBody
     */
    'fn_index'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PredictBody
     */
    'batched'?: boolean;
    /**
     * 
     * @type {Request}
     * @memberof PredictBody
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface PreprocessResponse
 */
export interface PreprocessResponse {
    /**
     * Response string from preprocessing task.
     * @type {string}
     * @memberof PreprocessResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface ProgressRequest
 */
export interface ProgressRequest {
    /**
     * id of the task to get progress for
     * @type {string}
     * @memberof ProgressRequest
     */
    'id_task'?: string;
    /**
     * id of last received last preview image
     * @type {number}
     * @memberof ProgressRequest
     */
    'id_live_preview'?: number;
}
/**
 * 
 * @export
 * @interface PromptStyleItem
 */
export interface PromptStyleItem {
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'negative_prompt'?: string;
}
/**
 * 
 * @export
 * @interface QuicksettingsHint
 */
export interface QuicksettingsHint {
    /**
     * 
     * @type {string}
     * @memberof QuicksettingsHint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof QuicksettingsHint
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface RealesrganItem
 */
export interface RealesrganItem {
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof RealesrganItem
     */
    'scale'?: number;
}
/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
}
/**
 * 
 * @export
 * @interface ResetBody
 */
export interface ResetBody {
    /**
     * 
     * @type {string}
     * @memberof ResetBody
     */
    'session_hash': string;
    /**
     * 
     * @type {number}
     * @memberof ResetBody
     */
    'fn_index': number;
}
/**
 * 
 * @export
 * @interface SDModelItem
 */
export interface SDModelItem {
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'model_name': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'sha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'config'?: string;
}
/**
 * 
 * @export
 * @interface SamplerItem
 */
export interface SamplerItem {
    /**
     * 
     * @type {string}
     * @memberof SamplerItem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SamplerItem
     */
    'aliases': Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SamplerItem
     */
    'options': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ScriptArg
 */
export interface ScriptArg {
    /**
     * Name of the argument in UI
     * @type {string}
     * @memberof ScriptArg
     */
    'label'?: string;
    /**
     * Default value of the argument
     * @type {any}
     * @memberof ScriptArg
     */
    'value'?: any;
    /**
     * Minimum allowed value for the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'minimum'?: any;
    /**
     * Maximum allowed value for the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'maximum'?: any;
    /**
     * Step for changing value of the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'step'?: any;
    /**
     * Possible values for the argument
     * @type {Array<string>}
     * @memberof ScriptArg
     */
    'choices'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ScriptInfo
 */
export interface ScriptInfo {
    /**
     * Script name
     * @type {string}
     * @memberof ScriptInfo
     */
    'name'?: string;
    /**
     * Flag specifying whether this script is an alwayson script
     * @type {boolean}
     * @memberof ScriptInfo
     */
    'is_alwayson'?: boolean;
    /**
     * Flag specifying whether this script is an img2img script
     * @type {boolean}
     * @memberof ScriptInfo
     */
    'is_img2img'?: boolean;
    /**
     * List of script\'s arguments
     * @type {Array<ScriptArg>}
     * @memberof ScriptInfo
     */
    'args': Array<ScriptArg>;
}
/**
 * 
 * @export
 * @interface ScriptsList
 */
export interface ScriptsList {
    /**
     * Titles of scripts (txt2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    'txt2img'?: Array<any>;
    /**
     * Titles of scripts (img2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    'img2img'?: Array<any>;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingImg2Img
 */
export interface StableDiffusionProcessingImg2Img {
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'init_images'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'resize_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'image_cfg_scale'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask_blur'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_fill'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res_padding'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_mask_invert'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'initial_noise_multiplier'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'sampler_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'do_not_save_samples'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'do_not_save_grid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_min_uncond'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'override_settings_restore_afterwards'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'script_args'?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'sampler_index'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'include_init_images'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'script_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'send_images'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'save_images'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'alwayson_scripts'?: object;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingTxt2Img
 */
export interface StableDiffusionProcessingTxt2Img {
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'enable_hr'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_scale'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_upscaler'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_second_pass_steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_resize_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_resize_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_sampler_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_negative_prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'sampler_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'do_not_save_samples'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'do_not_save_grid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_min_uncond'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'override_settings_restore_afterwards'?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'script_args'?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'sampler_index'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'script_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'send_images'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'save_images'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'alwayson_scripts'?: object;
}
/**
 * 
 * @export
 * @interface TaggerInterrogateRequest
 */
export interface TaggerInterrogateRequest {
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof TaggerInterrogateRequest
     */
    'image'?: string;
    /**
     * The interrogate model used.
     * @type {string}
     * @memberof TaggerInterrogateRequest
     */
    'model': string;
    /**
     * 
     * @type {number}
     * @memberof TaggerInterrogateRequest
     */
    'threshold'?: number;
}
/**
 * 
 * @export
 * @interface TaggerInterrogateResponse
 */
export interface TaggerInterrogateResponse {
    /**
     * The generated caption for the image.
     * @type {{ [key: string]: number; }}
     * @memberof TaggerInterrogateResponse
     */
    'caption': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface TextToImageResponse
 */
export interface TextToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof TextToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof TextToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof TextToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface TrainResponse
 */
export interface TrainResponse {
    /**
     * Response string from train embedding or hypernetwork task.
     * @type {string}
     * @memberof TrainResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface UpscalerItem
 */
export interface UpscalerItem {
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpscalerItem
     */
    'scale'?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * SdApi - axios parameter creator
 * @export
 */
export const SdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet: async (serialize?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serialize !== undefined) {
                localVarQueryParameter['serialize'] = serialize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet_1: async (serialize?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serialize !== undefined) {
                localVarQueryParameter['serialize'] = serialize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app_id/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet: async (path: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('buildResourceAssetsPathGet', 'path', path)
            const localVarPath = `/assets/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEmbeddingSdapiV1CreateEmbeddingPost', 'body', body)
            const localVarPath = `/sdapi/v1/create/embedding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createHypernetworkSdapiV1CreateHypernetworkPost', 'body', body)
            const localVarPath = `/sdapi/v1/create/hypernetwork`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [bodyDetectControlnetDetectPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectControlnetDetectPost: async (bodyDetectControlnetDetectPost?: BodyDetectControlnetDetectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controlnet/detect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyDetectControlnetDetectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint Interrogate
         * @param {TaggerInterrogateRequest} taggerInterrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInterrogateTaggerV1InterrogatePost: async (taggerInterrogateRequest: TaggerInterrogateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggerInterrogateRequest' is not null or undefined
            assertParamExists('endpointInterrogateTaggerV1InterrogatePost', 'taggerInterrogateRequest', taggerInterrogateRequest)
            const localVarPath = `/tagger/v1/interrogate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggerInterrogateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint Interrogators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInterrogatorsTaggerV1InterrogatorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tagger/v1/interrogators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost: async (extrasBatchImagesRequest: ExtrasBatchImagesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasBatchImagesRequest' is not null or undefined
            assertParamExists('extrasBatchImagesApiSdapiV1ExtraBatchImagesPost', 'extrasBatchImagesRequest', extrasBatchImagesRequest)
            const localVarPath = `/sdapi/v1/extra-batch-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extrasBatchImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost: async (extrasSingleImageRequest: ExtrasSingleImageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasSingleImageRequest' is not null or undefined
            assertParamExists('extrasSingleImageApiSdapiV1ExtraSingleImagePost', 'extrasSingleImageRequest', extrasSingleImageRequest)
            const localVarPath = `/sdapi/v1/extra-single-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extrasSingleImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favicon.ico`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet: async (filename?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sd_extra_networks/thumb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet: async (path: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('fileDeprecatedFilePathGet', 'path', path)
            const localVarPath = `/file/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlGet: async (pathOrUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathOrUrl' is not null or undefined
            assertParamExists('fileFilePathOrUrlGet', 'pathOrUrl', pathOrUrl)
            const localVarPath = `/file={path_or_url}`
                .replace(`{${"path_or_url"}}`, encodeURIComponent(String(pathOrUrl)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlHead: async (pathOrUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathOrUrl' is not null or undefined
            assertParamExists('fileFilePathOrUrlHead', 'pathOrUrl', pathOrUrl)
            const localVarPath = `/file={path_or_url}`
                .replace(`{${"path_or_url"}}`, encodeURIComponent(String(pathOrUrl)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/cmd-flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_3: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_4: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/face-restorers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/hypernetworks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLorasSdapiV1LorasGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/loras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/memory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSdExtraNetworksMetadataGet: async (page?: string, item?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sd_extra_networks/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (item !== undefined) {
                localVarQueryParameter['item'] = item;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/prompt-styles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/realesrgan-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/samplers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptInfoSdapiV1ScriptInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/script-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/sd-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_5: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/upscalers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost: async (stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingImg2Img' is not null or undefined
            assertParamExists('img2imgapiSdapiV1Img2imgPost', 'stableDiffusionProcessingImg2Img', stableDiffusionProcessingImg2Img)
            const localVarPath = `/sdapi/v1/img2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingImg2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost: async (interrogateRequest: InterrogateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interrogateRequest' is not null or undefined
            assertParamExists('interrogateapiSdapiV1InterrogatePost', 'interrogateRequest', interrogateRequest)
            const localVarPath = `/sdapi/v1/interrogate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interrogateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/interrupt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalPingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_check/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_6: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginLoginPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginLoginPost', 'password', password)
            const localVarPath = `/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_7: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginLoginPost_7', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginLoginPost_7', 'password', password)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelListControlnetModelListGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controlnet/model_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Module List
         * @param {boolean} [aliasNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleListControlnetModuleListGet: async (aliasNames?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controlnet/module_list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aliasNames !== undefined) {
                localVarQueryParameter['alias_names'] = aliasNames;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost: async (pNGInfoRequest: PNGInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pNGInfoRequest' is not null or undefined
            assertParamExists('pnginfoapiSdapiV1PngInfoPost', 'pNGInfoRequest', pNGInfoRequest)
            const localVarPath = `/sdapi/v1/png-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pNGInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost: async (apiName: string, predictBody: PredictBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictApiApiNamePost', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictApiApiNamePost', 'predictBody', predictBody)
            const localVarPath = `/api/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_8: async (apiName: string, predictBody: PredictBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictApiApiNamePost_8', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictApiApiNamePost_8', 'predictBody', predictBody)
            const localVarPath = `/api/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost: async (apiName: string, predictBody: PredictBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictRunApiNamePost', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictRunApiNamePost', 'predictBody', predictBody)
            const localVarPath = `/run/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_9: async (apiName: string, predictBody: PredictBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictRunApiNamePost_9', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictRunApiNamePost_9', 'predictBody', predictBody)
            const localVarPath = `/run/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Preprocess
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preprocessSdapiV1PreprocessPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('preprocessSdapiV1PreprocessPost', 'body', body)
            const localVarPath = `/sdapi/v1/preprocess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost: async (progressRequest: ProgressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'progressRequest' is not null or undefined
            assertParamExists('progressapiInternalProgressPost', 'progressRequest', progressRequest)
            const localVarPath = `/internal/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(progressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet: async (skipCurrentImage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCurrentImage !== undefined) {
                localVarQueryParameter['skip_current_image'] = skipCurrentImage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quicksettingsHintInternalQuicksettingsHintGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/quicksettings-hint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/refresh-checkpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLorasSdapiV1RefreshLorasPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/refresh-loras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadapiSdapiV1ReloadCheckpointPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/reload-checkpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rembg Remove
         * @param {BodyRembgRemoveRembgPost} [bodyRembgRemoveRembgPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rembgRemoveRembgPost: async (bodyRembgRemoveRembgPost?: BodyRembgRemoveRembgPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rembg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyRembgRemoveRembgPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost: async (resetBody: ResetBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetBody' is not null or undefined
            assertParamExists('resetIteratorResetPost', 'resetBody', resetBody)
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_10: async (resetBody: ResetBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetBody' is not null or undefined
            assertParamExists('resetIteratorResetPost_10', 'resetBody', resetBody)
            const localVarPath = `/reset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathGet: async (urlPath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlPath' is not null or undefined
            assertParamExists('reverseProxyProxyUrlPathGet', 'urlPath', urlPath)
            const localVarPath = `/proxy={url_path}`
                .replace(`{${"url_path"}}`, encodeURIComponent(String(urlPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathHead: async (urlPath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlPath' is not null or undefined
            assertParamExists('reverseProxyProxyUrlPathHead', 'urlPath', urlPath)
            const localVarPath = `/proxy={url_path}`
                .replace(`{${"url_path"}}`, encodeURIComponent(String(urlPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/robots.txt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('setConfigSdapiV1OptionsPost', 'body', body)
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControlnetSettingsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controlnet/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/skip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/startup-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet: async (path: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('staticResourceStaticPathGet', 'path', path)
            const localVarPath = `/static/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost: async (stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingTxt2Img' is not null or undefined
            assertParamExists('text2imgapiSdapiV1Txt2imgPost', 'stableDiffusionProcessingTxt2Img', stableDiffusionProcessingTxt2Img)
            const localVarPath = `/sdapi/v1/txt2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingTxt2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeCssThemeCssGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme.css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('trainEmbeddingSdapiV1TrainEmbeddingPost', 'body', body)
            const localVarPath = `/sdapi/v1/train/embedding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('trainHypernetworkSdapiV1TrainHypernetworkPost', 'body', body)
            const localVarPath = `/sdapi/v1/train/hypernetwork`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadapiSdapiV1UnloadCheckpointPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/unload-checkpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUploadPost: async (files: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadFileUploadPost', 'files', files)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionControlnetVersionGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controlnet/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SdApi - functional programming interface
 * @export
 */
export const SdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInfoInfoGet(serialize?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInfoInfoGet(serialize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInfoInfoGet_1(serialize?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInfoInfoGet_1(serialize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appIdAppIdGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appIdAppIdGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appIdAppIdGet_2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appIdAppIdGet_2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildResourceAssetsPathGet(path: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildResourceAssetsPathGet(path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbeddingSdapiV1CreateEmbeddingPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHypernetworkSdapiV1CreateHypernetworkPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [bodyDetectControlnetDetectPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectControlnetDetectPost(bodyDetectControlnetDetectPost?: BodyDetectControlnetDetectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectControlnetDetectPost(bodyDetectControlnetDetectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Endpoint Interrogate
         * @param {TaggerInterrogateRequest} taggerInterrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest: TaggerInterrogateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggerInterrogateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Endpoint Interrogators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointInterrogatorsTaggerV1InterrogatorsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterrogatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointInterrogatorsTaggerV1InterrogatorsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasBatchImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasSingleImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faviconFaviconIcoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faviconFaviconIcoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchFileSdExtraNetworksThumbGet(filename?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFileSdExtraNetworksThumbGet(filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDeprecatedFilePathGet(path: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDeprecatedFilePathGet(path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileFilePathOrUrlGet(pathOrUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileFilePathOrUrlGet(pathOrUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileFilePathOrUrlHead(pathOrUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileFilePathOrUrlHead(pathOrUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmdFlagsSdapiV1CmdFlagsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmdFlagsSdapiV1CmdFlagsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigConfigGet_3(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigConfigGet_3(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigSdapiV1OptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigSdapiV1OptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserUserGet_4(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserUserGet_4(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmbeddingsSdapiV1EmbeddingsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmbeddingsSdapiV1EmbeddingsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaceRestorersSdapiV1FaceRestorersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaceRestorerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaceRestorersSdapiV1FaceRestorersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHypernetworksSdapiV1HypernetworksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HypernetworkItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHypernetworksSdapiV1HypernetworksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLorasSdapiV1LorasGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLorasSdapiV1LorasGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemorySdapiV1MemoryGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemorySdapiV1MemoryGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataSdExtraNetworksMetadataGet(page, item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptStylesSdapiV1PromptStylesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptStyleItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptStylesSdapiV1PromptStylesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueStatusQueueStatusGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Estimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueStatusQueueStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealesrganModelsSdapiV1RealesrganModelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RealesrganItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealesrganModelsSdapiV1RealesrganModelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamplersSdapiV1SamplersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SamplerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamplersSdapiV1SamplersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScriptInfoSdapiV1ScriptInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScriptInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScriptInfoSdapiV1ScriptInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScriptsListSdapiV1ScriptsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScriptsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScriptsListSdapiV1ScriptsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdModelsSdapiV1SdModelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDModelItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdModelsSdapiV1SdModelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenTokenGet_5(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenTokenGet_5(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpscalersSdapiV1UpscalersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpscalerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpscalersSdapiV1UpscalersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interruptapiSdapiV1InterruptPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interruptapiSdapiV1InterruptPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lambdaInternalPingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaInternalPingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheckLoginCheckGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheckLoginCheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheckLoginCheckGet_6(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheckLoginCheckGet_6(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainHead(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainHead(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelListControlnetModelListGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelListControlnetModelListGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Module List
         * @param {boolean} [aliasNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleListControlnetModuleListGet(aliasNames?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleListControlnetModuleListGet(aliasNames, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PNGInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictApiApiNamePost(apiName, predictBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictApiApiNamePost_8(apiName, predictBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictRunApiNamePost(apiName, predictBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictRunApiNamePost_9(apiName, predictBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Preprocess
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preprocessSdapiV1PreprocessPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreprocessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preprocessSdapiV1PreprocessPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulesProgressProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.progressapiInternalProgressPost(progressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulesApiModelsProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.progressapiSdapiV1ProgressGet(skipCurrentImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quicksettingsHintInternalQuicksettingsHintGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuicksettingsHint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quicksettingsHintInternalQuicksettingsHintGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCheckpointsSdapiV1RefreshCheckpointsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLorasSdapiV1RefreshLorasPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLorasSdapiV1RefreshLorasPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reloadapiSdapiV1ReloadCheckpointPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadapiSdapiV1ReloadCheckpointPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rembg Remove
         * @param {BodyRembgRemoveRembgPost} [bodyRembgRemoveRembgPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rembgRemoveRembgPost(bodyRembgRemoveRembgPost?: BodyRembgRemoveRembgPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rembgRemoveRembgPost(bodyRembgRemoveRembgPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIteratorResetPost(resetBody: ResetBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIteratorResetPost(resetBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIteratorResetPost_10(resetBody: ResetBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIteratorResetPost_10(resetBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseProxyProxyUrlPathGet(urlPath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseProxyProxyUrlPathGet(urlPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseProxyProxyUrlPathHead(urlPath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseProxyProxyUrlPathHead(urlPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async robotsTxtRobotsTxtGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.robotsTxtRobotsTxtGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfigSdapiV1OptionsPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfigSdapiV1OptionsPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControlnetSettingsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControlnetSettingsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skipSdapiV1SkipPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skipSdapiV1SkipPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startupEventsStartupEventsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startupEventsStartupEventsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staticResourceStaticPathGet(path: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staticResourceStaticPathGet(path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeCssThemeCssGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeCssThemeCssGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainEmbeddingSdapiV1TrainEmbeddingPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainHypernetworkSdapiV1TrainHypernetworkPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unloadapiSdapiV1UnloadCheckpointPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unloadapiSdapiV1UnloadCheckpointPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileUploadPost(files: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileUploadPost(files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionControlnetVersionGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionControlnetVersionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SdApi - factory interface
 * @export
 */
export const SdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SdApiFp(configuration)
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet(serialize?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.apiInfoInfoGet(serialize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet_1(serialize?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.apiInfoInfoGet_1(serialize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet(options?: any): AxiosPromise<object> {
            return localVarFp.appIdAppIdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_2(options?: any): AxiosPromise<object> {
            return localVarFp.appIdAppIdGet_2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.buildResourceAssetsPathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: any): AxiosPromise<CreateResponse> {
            return localVarFp.createEmbeddingSdapiV1CreateEmbeddingPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: any): AxiosPromise<CreateResponse> {
            return localVarFp.createHypernetworkSdapiV1CreateHypernetworkPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detect
         * @param {BodyDetectControlnetDetectPost} [bodyDetectControlnetDetectPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectControlnetDetectPost(bodyDetectControlnetDetectPost?: BodyDetectControlnetDetectPost, options?: any): AxiosPromise<any> {
            return localVarFp.detectControlnetDetectPost(bodyDetectControlnetDetectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Endpoint Interrogate
         * @param {TaggerInterrogateRequest} taggerInterrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest: TaggerInterrogateRequest, options?: any): AxiosPromise<TaggerInterrogateResponse> {
            return localVarFp.endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Endpoint Interrogators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInterrogatorsTaggerV1InterrogatorsGet(options?: any): AxiosPromise<InterrogatorsResponse> {
            return localVarFp.endpointInterrogatorsTaggerV1InterrogatorsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: any): AxiosPromise<ExtrasBatchImagesResponse> {
            return localVarFp.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: any): AxiosPromise<ExtrasSingleImageResponse> {
            return localVarFp.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet(options?: any): AxiosPromise<any> {
            return localVarFp.faviconFaviconIcoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet(filename?: string, options?: any): AxiosPromise<any> {
            return localVarFp.fetchFileSdExtraNetworksThumbGet(filename, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileDeprecatedFilePathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlGet(pathOrUrl: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileFilePathOrUrlGet(pathOrUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlHead(pathOrUrl: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileFilePathOrUrlHead(pathOrUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options?: any): AxiosPromise<Flags> {
            return localVarFp.getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet(options?: any): AxiosPromise<any> {
            return localVarFp.getConfigConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_3(options?: any): AxiosPromise<any> {
            return localVarFp.getConfigConfigGet_3(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options?: any): AxiosPromise<Options> {
            return localVarFp.getConfigSdapiV1OptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet(options?: any): AxiosPromise<string> {
            return localVarFp.getCurrentUserUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_4(options?: any): AxiosPromise<string> {
            return localVarFp.getCurrentUserUserGet_4(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet(options?: any): AxiosPromise<EmbeddingsResponse> {
            return localVarFp.getEmbeddingsSdapiV1EmbeddingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options?: any): AxiosPromise<Array<FaceRestorerItem>> {
            return localVarFp.getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options?: any): AxiosPromise<Array<HypernetworkItem>> {
            return localVarFp.getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLorasSdapiV1LorasGet(options?: any): AxiosPromise<any> {
            return localVarFp.getLorasSdapiV1LorasGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet(options?: any): AxiosPromise<MemoryResponse> {
            return localVarFp.getMemorySdapiV1MemoryGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMetadataSdExtraNetworksMetadataGet(page, item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet(options?: any): AxiosPromise<Array<PromptStyleItem>> {
            return localVarFp.getPromptStylesSdapiV1PromptStylesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet(options?: any): AxiosPromise<Estimation> {
            return localVarFp.getQueueStatusQueueStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any): AxiosPromise<Array<RealesrganItem>> {
            return localVarFp.getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options?: any): AxiosPromise<Array<SamplerItem>> {
            return localVarFp.getSamplersSdapiV1SamplersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptInfoSdapiV1ScriptInfoGet(options?: any): AxiosPromise<Array<ScriptInfo>> {
            return localVarFp.getScriptInfoSdapiV1ScriptInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet(options?: any): AxiosPromise<ScriptsList> {
            return localVarFp.getScriptsListSdapiV1ScriptsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options?: any): AxiosPromise<Array<SDModelItem>> {
            return localVarFp.getSdModelsSdapiV1SdModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet(options?: any): AxiosPromise<object> {
            return localVarFp.getTokenTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_5(options?: any): AxiosPromise<object> {
            return localVarFp.getTokenTokenGet_5(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options?: any): AxiosPromise<Array<UpscalerItem>> {
            return localVarFp.getUpscalersSdapiV1UpscalersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: any): AxiosPromise<ImageToImageResponse> {
            return localVarFp.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options?: any): AxiosPromise<any> {
            return localVarFp.interruptapiSdapiV1InterruptPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalPingGet(options?: any): AxiosPromise<any> {
            return localVarFp.lambdaInternalPingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet(options?: any): AxiosPromise<any> {
            return localVarFp.loginCheckLoginCheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_6(options?: any): AxiosPromise<any> {
            return localVarFp.loginCheckLoginCheckGet_6(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<any> {
            return localVarFp.loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<any> {
            return localVarFp.loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any): AxiosPromise<string> {
            return localVarFp.mainGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead(options?: any): AxiosPromise<string> {
            return localVarFp.mainHead(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Model List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelListControlnetModelListGet(options?: any): AxiosPromise<any> {
            return localVarFp.modelListControlnetModelListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Module List
         * @param {boolean} [aliasNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleListControlnetModuleListGet(aliasNames?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.moduleListControlnetModuleListGet(aliasNames, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: any): AxiosPromise<PNGInfoResponse> {
            return localVarFp.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictApiApiNamePost(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictApiApiNamePost_8(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictRunApiNamePost(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictRunApiNamePost_9(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Preprocess
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preprocessSdapiV1PreprocessPost(body: object, options?: any): AxiosPromise<PreprocessResponse> {
            return localVarFp.preprocessSdapiV1PreprocessPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: any): AxiosPromise<ModulesProgressProgressResponse> {
            return localVarFp.progressapiInternalProgressPost(progressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any): AxiosPromise<ModulesApiModelsProgressResponse> {
            return localVarFp.progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quicksettingsHintInternalQuicksettingsHintGet(options?: any): AxiosPromise<Array<QuicksettingsHint>> {
            return localVarFp.quicksettingsHintInternalQuicksettingsHintGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: any): AxiosPromise<any> {
            return localVarFp.refreshCheckpointsSdapiV1RefreshCheckpointsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLorasSdapiV1RefreshLorasPost(options?: any): AxiosPromise<any> {
            return localVarFp.refreshLorasSdapiV1RefreshLorasPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadapiSdapiV1ReloadCheckpointPost(options?: any): AxiosPromise<any> {
            return localVarFp.reloadapiSdapiV1ReloadCheckpointPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rembg Remove
         * @param {BodyRembgRemoveRembgPost} [bodyRembgRemoveRembgPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rembgRemoveRembgPost(bodyRembgRemoveRembgPost?: BodyRembgRemoveRembgPost, options?: any): AxiosPromise<any> {
            return localVarFp.rembgRemoveRembgPost(bodyRembgRemoveRembgPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost(resetBody: ResetBody, options?: any): AxiosPromise<any> {
            return localVarFp.resetIteratorResetPost(resetBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_10(resetBody: ResetBody, options?: any): AxiosPromise<any> {
            return localVarFp.resetIteratorResetPost_10(resetBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathGet(urlPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseProxyProxyUrlPathGet(urlPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathHead(urlPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseProxyProxyUrlPathHead(urlPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet(options?: any): AxiosPromise<string> {
            return localVarFp.robotsTxtRobotsTxtGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(body: object, options?: any): AxiosPromise<any> {
            return localVarFp.setConfigSdapiV1OptionsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControlnetSettingsGet(options?: any): AxiosPromise<any> {
            return localVarFp.settingsControlnetSettingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost(options?: any): AxiosPromise<any> {
            return localVarFp.skipSdapiV1SkipPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet(options?: any): AxiosPromise<any> {
            return localVarFp.startupEventsStartupEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.staticResourceStaticPathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: any): AxiosPromise<TextToImageResponse> {
            return localVarFp.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeCssThemeCssGet(options?: any): AxiosPromise<string> {
            return localVarFp.themeCssThemeCssGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: any): AxiosPromise<TrainResponse> {
            return localVarFp.trainEmbeddingSdapiV1TrainEmbeddingPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: any): AxiosPromise<TrainResponse> {
            return localVarFp.trainHypernetworkSdapiV1TrainHypernetworkPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadapiSdapiV1UnloadCheckpointPost(options?: any): AxiosPromise<any> {
            return localVarFp.unloadapiSdapiV1UnloadCheckpointPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUploadPost(files: Array<File>, options?: any): AxiosPromise<any> {
            return localVarFp.uploadFileUploadPost(files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionControlnetVersionGet(options?: any): AxiosPromise<any> {
            return localVarFp.versionControlnetVersionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SdApi - object-oriented interface
 * @export
 * @class SdApi
 * @extends {BaseAPI}
 */
export class SdApi extends BaseAPI {
    /**
     * 
     * @summary Api Info
     * @param {boolean} [serialize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public apiInfoInfoGet(serialize?: boolean, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).apiInfoInfoGet(serialize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Api Info
     * @param {boolean} [serialize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public apiInfoInfoGet_1(serialize?: boolean, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).apiInfoInfoGet_1(serialize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public appIdAppIdGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).appIdAppIdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public appIdAppIdGet_2(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).appIdAppIdGet_2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public buildResourceAssetsPathGet(path: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).buildResourceAssetsPathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Embedding
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).createEmbeddingSdapiV1CreateEmbeddingPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Hypernetwork
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).createHypernetworkSdapiV1CreateHypernetworkPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detect
     * @param {BodyDetectControlnetDetectPost} [bodyDetectControlnetDetectPost] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public detectControlnetDetectPost(bodyDetectControlnetDetectPost?: BodyDetectControlnetDetectPost, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).detectControlnetDetectPost(bodyDetectControlnetDetectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Endpoint Interrogate
     * @param {TaggerInterrogateRequest} taggerInterrogateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest: TaggerInterrogateRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).endpointInterrogateTaggerV1InterrogatePost(taggerInterrogateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Endpoint Interrogators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public endpointInterrogatorsTaggerV1InterrogatorsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).endpointInterrogatorsTaggerV1InterrogatorsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extras Batch Images Api
     * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extras Single Image Api
     * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Favicon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public faviconFaviconIcoGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).faviconFaviconIcoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch File
     * @param {string} [filename] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public fetchFileSdExtraNetworksThumbGet(filename?: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).fetchFileSdExtraNetworksThumbGet(filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File Deprecated
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public fileDeprecatedFilePathGet(path: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).fileDeprecatedFilePathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File
     * @param {string} pathOrUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public fileFilePathOrUrlGet(pathOrUrl: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).fileFilePathOrUrlGet(pathOrUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File
     * @param {string} pathOrUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public fileFilePathOrUrlHead(pathOrUrl: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).fileFilePathOrUrlHead(pathOrUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cmd Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getCmdFlagsSdapiV1CmdFlagsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getConfigConfigGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getConfigConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getConfigConfigGet_3(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getConfigConfigGet_3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getConfigSdapiV1OptionsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getConfigSdapiV1OptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getCurrentUserUserGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getCurrentUserUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getCurrentUserUserGet_4(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getCurrentUserUserGet_4(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Embeddings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getEmbeddingsSdapiV1EmbeddingsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getEmbeddingsSdapiV1EmbeddingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Face Restorers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getFaceRestorersSdapiV1FaceRestorersGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hypernetworks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getHypernetworksSdapiV1HypernetworksGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Loras
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getLorasSdapiV1LorasGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getLorasSdapiV1LorasGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getMemorySdapiV1MemoryGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getMemorySdapiV1MemoryGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Metadata
     * @param {string} [page] 
     * @param {string} [item] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getMetadataSdExtraNetworksMetadataGet(page, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Prompt Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getPromptStylesSdapiV1PromptStylesGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getPromptStylesSdapiV1PromptStylesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Queue Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getQueueStatusQueueStatusGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getQueueStatusQueueStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Realesrgan Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getRealesrganModelsSdapiV1RealesrganModelsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Samplers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getSamplersSdapiV1SamplersGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getSamplersSdapiV1SamplersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Script Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getScriptInfoSdapiV1ScriptInfoGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getScriptInfoSdapiV1ScriptInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Scripts List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getScriptsListSdapiV1ScriptsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getScriptsListSdapiV1ScriptsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sd Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getSdModelsSdapiV1SdModelsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getSdModelsSdapiV1SdModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getTokenTokenGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getTokenTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getTokenTokenGet_5(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getTokenTokenGet_5(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Upscalers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public getUpscalersSdapiV1UpscalersGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).getUpscalersSdapiV1UpscalersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Img2Imgapi
     * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interrogateapi
     * @param {InterrogateRequest} interrogateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interruptapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public interruptapiSdapiV1InterruptPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).interruptapiSdapiV1InterruptPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary <Lambda>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public lambdaInternalPingGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).lambdaInternalPingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public loginCheckLoginCheckGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).loginCheckLoginCheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public loginCheckLoginCheckGet_6(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).loginCheckLoginCheckGet_6(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public mainGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).mainGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public mainHead(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).mainHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Model List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public modelListControlnetModelListGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).modelListControlnetModelListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Module List
     * @param {boolean} [aliasNames] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public moduleListControlnetModuleListGet(aliasNames?: boolean, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).moduleListControlnetModuleListGet(aliasNames, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pnginfoapi
     * @param {PNGInfoRequest} pNGInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).predictApiApiNamePost(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).predictApiApiNamePost_8(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).predictRunApiNamePost(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).predictRunApiNamePost_9(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Preprocess
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public preprocessSdapiV1PreprocessPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).preprocessSdapiV1PreprocessPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Progressapi
     * @param {ProgressRequest} progressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).progressapiInternalProgressPost(progressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Progressapi
     * @param {boolean} [skipCurrentImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Quicksettings Hint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public quicksettingsHintInternalQuicksettingsHintGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).quicksettingsHintInternalQuicksettingsHintGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Checkpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).refreshCheckpointsSdapiV1RefreshCheckpointsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Loras
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public refreshLorasSdapiV1RefreshLorasPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).refreshLorasSdapiV1RefreshLorasPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reloadapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public reloadapiSdapiV1ReloadCheckpointPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).reloadapiSdapiV1ReloadCheckpointPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rembg Remove
     * @param {BodyRembgRemoveRembgPost} [bodyRembgRemoveRembgPost] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public rembgRemoveRembgPost(bodyRembgRemoveRembgPost?: BodyRembgRemoveRembgPost, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).rembgRemoveRembgPost(bodyRembgRemoveRembgPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} resetBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public resetIteratorResetPost(resetBody: ResetBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).resetIteratorResetPost(resetBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} resetBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public resetIteratorResetPost_10(resetBody: ResetBody, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).resetIteratorResetPost_10(resetBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Proxy
     * @param {string} urlPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public reverseProxyProxyUrlPathGet(urlPath: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).reverseProxyProxyUrlPathGet(urlPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Proxy
     * @param {string} urlPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public reverseProxyProxyUrlPathHead(urlPath: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).reverseProxyProxyUrlPathHead(urlPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Robots Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public robotsTxtRobotsTxtGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).robotsTxtRobotsTxtGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Config
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public setConfigSdapiV1OptionsPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).setConfigSdapiV1OptionsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public settingsControlnetSettingsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).settingsControlnetSettingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public skipSdapiV1SkipPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).skipSdapiV1SkipPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Startup Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public startupEventsStartupEventsGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).startupEventsStartupEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Static Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public staticResourceStaticPathGet(path: string, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).staticResourceStaticPathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Text2Imgapi
     * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Theme Css
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public themeCssThemeCssGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).themeCssThemeCssGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Train Embedding
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).trainEmbeddingSdapiV1TrainEmbeddingPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Train Hypernetwork
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).trainHypernetworkSdapiV1TrainHypernetworkPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unloadapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public unloadapiSdapiV1UnloadCheckpointPost(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).unloadapiSdapiV1UnloadCheckpointPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {Array<File>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public uploadFileUploadPost(files: Array<File>, options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).uploadFileUploadPost(files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SdApi
     */
    public versionControlnetVersionGet(options?: AxiosRequestConfig) {
        return SdApiFp(this.configuration).versionControlnetVersionGet(options).then((request) => request(this.axios, this.basePath));
    }
}


